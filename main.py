#!/usr/bin/env python3
"""
Bot Elite de Sinais Bac Bo para Telegram
Vers√£o Profissional com Funcionalidades Avan√ßadas
"""

import os
import time
import random
import json
import sqlite3
import logging
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple
import telebot
from telebot.types import InlineKeyboardMarkup, InlineKeyboardButton, ReplyKeyboardMarkup, KeyboardButton
import threading
from dataclasses import dataclass, asdict
from enum import Enum
from comandos_bot_avancados import adicionar_comandos_avancados

# Configura√ß√£o de logging
logging.basicConfig(
    level=logging.INFO,
    format=\'%(asctime)s - %(name)s - %(levelname)s - %(message)s\',
    handlers=[
        logging.FileHandler(\'bot_bacbo.log\'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

class TipoAposta(Enum):
    PLAYER = "Player"
    BANKER = "Banker"
    TIE = "Tie"

@dataclass
class Sinal:
    id: int
    tipo: str
    timestamp: datetime
    nivel_martingale: int
    valor_aposta: float
    resultado: Optional[bool] = None
    timestamp_resultado: Optional[datetime] = None

@dataclass
class Configuracao:
    banca_minima: float = 100.0
    martingale_niveis: List[float] = None
    intervalo_sinais_minutos: int = 15
    taxa_vitoria_simulada: float = 0.70
    stop_loss_niveis: int = 3
    pausa_stop_loss_horas: int = 12
    url_cadastro: str = "https://lkwn.cc/f1c1c45a"
    
    def __post_init__(self ):
        if self.martingale_niveis is None:
            self.martingale_niveis = [0.01, 0.02, 0.04]

class DatabaseManager:
    def __init__(self, db_path: str = "bot_bacbo.db"):
        self.db_path = db_path
        self.init_database()
    
    def init_database(self):
        """Inicializa o banco de dados com as tabelas necess√°rias"""
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.cursor()
            
            # Tabela de sinais
            cursor.execute(\'\'\'
                CREATE TABLE IF NOT EXISTS sinais (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    tipo TEXT NOT NULL,
                    timestamp TEXT NOT NULL,
                    nivel_martingale INTEGER NOT NULL,
                    valor_aposta REAL NOT NULL,
                    resultado INTEGER,
                    timestamp_resultado TEXT
                )
            \'\'\')
            
            # Tabela de configura√ß√µes
            cursor.execute(\'\'\'
                CREATE TABLE IF NOT EXISTS configuracoes (
                    chave TEXT PRIMARY KEY,
                    valor TEXT NOT NULL
                )
            \'\'\')
            
            # Tabela de estat√≠sticas
            cursor.execute(\'\'\'
                CREATE TABLE IF NOT EXISTS estatisticas (
                    data TEXT PRIMARY KEY,
                    total_sinais INTEGER DEFAULT 0,
                    total_greens INTEGER DEFAULT 0,
                    total_reds INTEGER DEFAULT 0,
                    lucro_dia REAL DEFAULT 0.0
                )
            \'\'\')
            
            conn.commit()
    
    def salvar_sinal(self, sinal: Sinal) -> int:
        """Salva um sinal no banco de dados"""
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.cursor()
            cursor.execute(\'\'\'
                INSERT INTO sinais (tipo, timestamp, nivel_martingale, valor_aposta, resultado, timestamp_resultado)
                VALUES (?, ?, ?, ?, ?, ?)
            \'\'\', (
                sinal.tipo,
                sinal.timestamp.isoformat(),
                sinal.nivel_martingale,
                sinal.valor_aposta,
                sinal.resultado,
                sinal.timestamp_resultado.isoformat() if sinal.timestamp_resultado else None
            ))
            return cursor.lastrowid
    
    def atualizar_resultado_sinal(self, sinal_id: int, resultado: bool):
        """Atualiza o resultado de um sinal"""
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.cursor()
            cursor.execute(\'\'\'
                UPDATE sinais 
                SET resultado = ?, timestamp_resultado = ?
                WHERE id = ?
            \'\'\', (resultado, datetime.now().isoformat(), sinal_id))
            conn.commit()
    
    def obter_estatisticas_periodo(self, dias: int = 7) -> Dict:
        """Obt√©m estat√≠sticas dos √∫ltimos N dias"""
        data_inicio = datetime.now() - timedelta(days=dias)
        
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.cursor()
            cursor.execute(\'\'\'
                SELECT 
                    COUNT(*) as total_sinais,
                    SUM(CASE WHEN resultado = 1 THEN 1 ELSE 0 END) as greens,
                    SUM(CASE WHEN resultado = 0 THEN 1 ELSE 0 END) as reds,
                    AVG(CASE WHEN resultado IS NOT NULL THEN resultado END) as taxa_acerto
                FROM sinais 
                WHERE timestamp >= ? AND resultado IS NOT NULL
            \'\'\', (data_inicio.isoformat(),))
            
            resultado = cursor.fetchone()
            
            return {
                \'total_sinais\': resultado[0] or 0,
                \'greens\': resultado[1] or 0,
                \'reds\': resultado[2] or 0,
                \'taxa_acerto\': resultado[3] or 0.0
            }

class AnalisadorPadroes:
    def __init__(self, db_manager: DatabaseManager):
        self.db = db_manager
    
    def analisar_sequencias(self) -> Dict:
        """Analisa sequ√™ncias de resultados para identificar padr√µes"""
        with sqlite3.connect(self.db.db_path) as conn:
            cursor = conn.cursor()
            cursor.execute(\'\'\'
                SELECT tipo, resultado 
                FROM sinais 
                WHERE resultado IS NOT NULL 
                ORDER BY timestamp DESC 
                LIMIT 50
            \'\'\')
            
            resultados = cursor.fetchall()
            
            # An√°lise de sequ√™ncias por tipo
            sequencias = {}
            for tipo in [TipoAposta.PLAYER.value, TipoAposta.BANKER.value, TipoAposta.TIE.value]:
                tipo_resultados = [r[1] for r in resultados if r[0] == tipo]
                sequencias[tipo] = {
                    \'total\': len(tipo_resultados),
                    \'greens\': sum(tipo_resultados),
                    \'taxa_acerto\': sum(tipo_resultados) / len(tipo_resultados) if tipo_resultados else 0
                }
            
            return sequencias
    
    def sugerir_proximo_sinal(self) -> str:
        """Sugere o pr√≥ximo sinal baseado em an√°lise de padr√µes"""
        padroes = self.analisador.analisar_sequencias()
        
        # L√≥gica simples: escolhe o tipo com menor taxa de acerto recente
        # (assumindo que haver√° uma corre√ß√£o)
        menor_taxa = float(\'inf\')
        tipo_sugerido = TipoAposta.PLAYER.value
        
        for tipo, dados in padroes.items():
            if dados[\'total\'] > 5 and dados[\'taxa_acerto\'] < menor_taxa:
                menor_taxa = dados[\'taxa_acerto\']
                tipo_sugerido = tipo
        
        return tipo_sugerido

class BacBoEliteBot:
    def __init__(self, config_path: str = "config.json"):
        self.config = self._carregar_configuracao(config_path)
        self.db = DatabaseManager()
        self.analisador = AnalisadorPadroes(self.db)
        
        # Configura√ß√£o do bot
        self.TOKEN = os.getenv("TELEGRAM_TOKEN")
        self.CHAT_ID = os.getenv("TELEGRAM_CHAT_ID")
        self.ADMIN_ID = os.getenv("TELEGRAM_ADMIN_ID")
        
        if not self.TOKEN or not self.CHAT_ID:
            logger.error("Vari√°veis de ambiente n√£o configuradas")
            exit()
        
        self.bot = telebot.TeleBot(self.TOKEN)
        self._configurar_handlers()
        
        # Estado do bot
        self.nivel_martingale_atual = 0
        self.banca_atual = self.config.banca_minima
        self.sinal_atual_id = None
        self.bot_ativo = False
        self.modo_automatico = True
        
        # Emojis e op√ß√µes
        self.emojis = {
            TipoAposta.PLAYER.value: "üîµ",
            TipoAposta.BANKER.value: "üî¥", 
            TipoAposta.TIE.value: "üü¢"
        }
    
    def _carregar_configuracao(self, config_path: str) -> Configuracao:
        """Carrega configura√ß√£o do arquivo JSON"""
        if os.path.exists(config_path):
            with open(config_path, \'r\') as f:
                config_dict = json.load(f)
                return Configuracao(**config_dict)
        else:
            config = Configuracao()
            self._salvar_configuracao(config, config_path)
            return config
    
    def _salvar_configuracao(self, config: Configuracao, config_path: str):
        """Salva configura√ß√£o no arquivo JSON"""
        with open(config_path, \'w\') as f:
            json.dump(asdict(config), f, indent=2)
    
    def _configurar_handlers(self):
        """Configura os handlers de comandos do bot"""
        
        @self.bot.message_handler(commands=[\'start\', \'help\'])
        def handle_start(message):
            if str(message.from_user.id) == self.ADMIN_ID:
                self._enviar_menu_admin(message.chat.id)
            else:
                self._enviar_mensagem_boas_vindas(message.chat.id)
        
        @self.bot.message_handler(commands=[\'stats\'])
        def handle_stats(message):
            if str(message.from_user.id) == self.ADMIN_ID:
                self._enviar_estatisticas(message.chat.id)
        
        @self.bot.message_handler(commands=[\'config\'])
        def handle_config(message):
            if str(message.from_user.id) == self.ADMIN_ID:
                self._enviar_menu_configuracao(message.chat.id)
        
        @self.bot.message_handler(commands=[\'iniciar\'])
        def handle_iniciar(message):
            if str(message.from_user.id) == self.ADMIN_ID:
                self._iniciar_bot_automatico()
        
        @self.bot.message_handler(commands=[\'parar\'])
        def handle_parar(message):
            if str(message.from_user.id) == self.ADMIN_ID:
                self._parar_bot_automatico()
        
        @self.bot.message_handler(commands=[\'sinal\'])
        def handle_sinal_manual(message):
            if str(message.from_user.id) == self.ADMIN_ID:
                self._enviar_sinal_manual()
        
        @self.bot.message_handler(commands=[\'green\'])
        def handle_green(message):
            if str(message.from_user.id) == self.ADMIN_ID:
                self._processar_resultado(True)
        
        @self.bot.message_handler(commands=[\'red\'])
        def handle_red(message):
            if str(message.from_user.id) == self.ADMIN_ID:
                self._processar_resultado(False)
        
        adicionar_comandos_avancados(self.bot)    
    def _enviar_menu_admin(self, chat_id):
        """Envia menu administrativo"""
        markup = ReplyKeyboardMarkup(resize_keyboard=True)
        markup.row(KeyboardButton("üìä Estat√≠sticas"), KeyboardButton("‚öôÔ∏è Configura√ß√µes"))
        markup.row(KeyboardButton("‚ñ∂Ô∏è Iniciar Bot"), KeyboardButton("‚èπÔ∏è Parar Bot"))
        markup.row(KeyboardButton("üéØ Sinal Manual"), KeyboardButton("üìà Relat√≥rio"))
        
        mensagem = (
            "ü§ñ **PAINEL ADMINISTRATIVO - BAC BO ELITE**\n\n"
            "Escolha uma op√ß√£o do menu abaixo:\n\n"
            "üìä **Estat√≠sticas** - Ver performance do bot\n"
            "‚öôÔ∏è **Configura√ß√µes** - Ajustar par√¢metros\n"
            "‚ñ∂Ô∏è **Iniciar Bot** - Ativar sinais autom√°ticos\n"
            "‚èπÔ∏è **Parar Bot** - Pausar sinais autom√°ticos\n"
            "üéØ **Sinal Manual** - Enviar sinal manualmente\n"
            "üìà **Relat√≥rio** - Relat√≥rio detalhado"
        )
        
        self.bot.send_message(chat_id, mensagem, parse_mode="Markdown", reply_markup=markup)
    
    def _enviar_mensagem_boas_vindas(self, chat_id):
        """Envia mensagem de boas-vindas para usu√°rios comuns"""
        botoes = InlineKeyboardMarkup()
        botoes.add(InlineKeyboardButton("üéÅ Cadastre-se e Ganhe B√¥nus", url=self.config.url_cadastro))
        
        mensagem = (
            "üé∞ **BEM-VINDO AO BAC BO ELITE** üé∞\n\n"
            "üî• **Sinais Premium de Alta Precis√£o**\n"
            "üí∞ **Gest√£o Profissional de Banca**\n"
            "üìä **An√°lise Avan√ßada de Padr√µes**\n"
            "üéØ **Taxa de Acerto Comprovada**\n\n"
            "Prepare-se para receber os melhores sinais do mercado!\n\n"
            "‚ö†Ô∏è **Lembre-se:** Jogue com responsabilidade e siga sempre a gest√£o de banca."
        )
        
        self.bot.send_message(chat_id, mensagem, parse_mode="Markdown", reply_markup=botoes)
    
    def _enviar_estatisticas(self, chat_id):
        """Envia estat√≠sticas detalhadas"""
        stats_7d = self.db.obter_estatisticas_periodo(7)
        stats_30d = self.db.obter_estatisticas_periodo(30)
        padroes = self.analisador.analisar_sequencias()
        
        mensagem = (
            "üìä **ESTAT√çSTICAS DO BOT** üìä\n\n"
            "**üìÖ √öltimos 7 dias:**\n"
            f"‚Ä¢ Total de sinais: {stats_7d[\'total_sinais\']}\n"
            f"‚Ä¢ Greens: {stats_7d[\'greens\']} ‚úÖ\n"
            f"‚Ä¢ Reds: {stats_7d[\'reds\']} ‚ùå\n"
            f"‚Ä¢ Taxa de acerto: {stats_7d[\'taxa_acerto\']:.1%}\n\n"
            
            "**üìÖ √öltimos 30 dias:**\n"
            f"‚Ä¢ Total de sinais: {stats_30d[\'total_sinais\']}\n"
            f"‚Ä¢ Greens: {stats_30d[\'greens\']} ‚úÖ\n"
            f"‚Ä¢ Reds: {stats_30d[\'reds\']} ‚ùå\n"
            f"‚Ä¢ Taxa de acerto: {stats_30d[\'taxa_acerto\']:.1%}\n\n"
            
            "**üéØ An√°lise por Tipo:**\n"
        )
        
        for tipo, dados in padroes.items():
            emoji = self.emojis.get(tipo, "‚ö™")
            mensagem += f"‚Ä¢ {emoji} {tipo}: {dados[\'taxa_acerto\']:.1%} ({dados[\'greens\']}/{dados[\'total\']})\n"
        
        mensagem += f"\n**üí∞ Banca Atual:** R$ {self.banca_atual:.2f}"
        mensagem += f"\n**üé≤ N√≠vel Martingale:** {self.nivel_martingale_atual + 1}"
        mensagem += f"\n**ü§ñ Status:** {\'üü¢ Ativo\' if self.bot_ativo else \'üî¥ Inativo\'}"
        
        self.bot.send_message(chat_id, mensagem, parse_mode="Markdown")
    
    def gerar_sinal_inteligente(self) -> Tuple[str, str]:
        """Gera sinal usando an√°lise de padr√µes"""
        if self.modo_automatico:
            # Usa an√°lise de padr√µes para sugerir
            tipo_sugerido = self.analisador.sugerir_proximo_sinal()
        else:
            # Fallback para escolha aleat√≥ria
            tipo_sugerido = random.choice([t.value for t in TipoAposta])
        
        emoji = self.emojis[tipo_sugerido]
        return tipo_sugerido, emoji
    
    def enviar_sinal(self, tipo: str = None, emoji: str = None) -> int:
        """Envia sinal para o canal"""
        if not tipo or not emoji:
            tipo, emoji = self.gerar_sinal_inteligente()
        
        percentual_aposta = self.config.martingale_niveis[self.nivel_martingale_atual]
        valor_aposta = self.banca_atual * percentual_aposta
        
        # Cria objeto sinal
        sinal = Sinal(
            id=0,  # Ser√° definido pelo banco
            tipo=tipo,
            timestamp=datetime.now(),
            nivel_martingale=self.nivel_martingale_atual,
            valor_aposta=valor_aposta
        )
        
        # Salva no banco
        sinal_id = self.db.salvar_sinal(sinal)
        self.sinal_atual_id = sinal_id
        
        # Informa√ß√µes de gest√£o
        gestao_info = (
            f"**üí∞ Gest√£o de Banca Profissional:**\n"
            f"‚Ä¢ **Banca Atual:** R$ {self.banca_atual:.2f}\n"
            f"‚Ä¢ **N√≠vel Martingale:** {self.nivel_martingale_atual + 1}/{len(self.config.martingale_niveis)}\n"
            f"‚Ä¢ **Aposta Sugerida:** {percentual_aposta:.2%} da banca (R$ {valor_aposta:.2f})\n"
            f"‚Ä¢ **Stop Loss:** {self.config.stop_loss_niveis} n√≠veis"
        )
        
        # An√°lise t√©cnica
        padroes = self.analisador.analisar_sequencias()
        tipo_stats = padroes.get(tipo, {\'taxa_acerto\': 0, \'total\': 0})
        
        analise_info = (
            f"**üìä An√°lise T√©cnica:**\n"
            f"‚Ä¢ **Tipo:** {tipo} {emoji}\n"
            f"‚Ä¢ **Taxa Recente:** {tipo_stats[\'taxa_acerto\']:.1%}\n"
            f"‚Ä¢ **Confian√ßa:** {\'üî• Alta\' if tipo_stats[\'taxa_acerto\'] > 0.6 else \'‚ö° M√©dia\' if tipo_stats[\'taxa_acerto\'] > 0.4 else \'‚ö†Ô∏è Baixa\'}"
        )
        
        mensagem = (
            "üö® **SINAL ELITE CONFIRMADO | BAC BO** üö®\n\n"
            f"üéØ **ENTRADA:** {emoji} **{tipo}**\n\n"
            f"{gestao_info}\n\n"
            f"{analise_info}\n\n"
            "‚ö†Ô∏è **IMPORTANTE:**\n"
            "‚Ä¢ Siga rigorosamente a gest√£o de banca\n"
            "‚Ä¢ Nunca aposte mais que o sugerido\n"
            "‚Ä¢ A disciplina √© fundamental para o sucesso\n\n"
            "üî• **BOA SORTE E TRADE RESPONS√ÅVEL!**"
        )
        
        botoes = InlineKeyboardMarkup()
        botoes.add(InlineKeyboardButton("üéÅ Cadastre-se e Ganhe B√¥nus", url=self.config.url_cadastro))
        
        self.bot.send_message(self.CHAT_ID, mensagem, parse_mode="Markdown", reply_markup=botoes)
        logger.info(f"Sinal enviado: {tipo} | N√≠vel: {self.nivel_martingale_atual + 1} | ID: {sinal_id}")
        
        return sinal_id
    
    def _processar_resultado(self, vitoria: bool):
        """Processa o resultado de um sinal"""
        if not self.sinal_atual_id:
            return
        
        # Atualiza no banco
        self.db.atualizar_resultado_sinal(self.sinal_atual_id, vitoria)
        
        if vitoria:
            # GREEN - Reseta martingale e atualiza banca
            percentual_ganho = self.config.martingale_niveis[self.nivel_martingale_atual]
            ganho = self.banca_atual * percentual_ganho * 0.95  # Considerando odds
            self.banca_atual += ganho
            self.nivel_martingale_atual = 0
            
            mensagem = (
                "‚úÖ **GREEN CONFIRMADO!** ‚úÖ\n\n"
                f"üéâ **Parab√©ns! Sinal finalizado com sucesso!**\n\n"
                f"üí∞ **Ganho:** R$ {ganho:.2f}\n"
                f"üí≥ **Nova Banca:** R$ {self.banca_atual:.2f}\n\n"
                "üîÑ **Voltamos ao n√≠vel 1 do Martingale**\n"
                "üéØ **Aguarde o pr√≥ximo sinal...**"
            )
            logger.info(f"GREEN - Ganho: R$ {ganho:.2f} | Nova banca: R$ {self.banca_atual:.2f}")
            
        else:
            # RED - Avan√ßa martingale
            self.nivel_martingale_atual += 1
            
            if self.nivel_martingale_atual >= len(self.config.martingale_niveis):
                # Stop Loss atingido
                self._executar_stop_loss()
                return
            
            proximo_percentual = self.config.martingale_niveis[self.nivel_martingale_atual]
            proxima_aposta = self.banca_atual * proximo_percentual
            
            mensagem = (
                "‚ùå **RED!** ‚ùå\n\n"
                f"‚ö†Ô∏è **Sinal n√£o bateu desta vez**\n\n"
                f"üé≤ **Pr√≥ximo n√≠vel:** {self.nivel_martingale_atual + 1}/{len(self.config.martingale_niveis)}\n"
                f"üí∞ **Pr√≥xima aposta:** R$ {proxima_aposta:.2f}\n\n"
                "üî• **Mantenha a disciplina!**\n"
                "üìà **A recupera√ß√£o est√° chegando...**"
            )
            logger.info(f"RED - N√≠vel: {self.nivel_martingale_atual + 1}")
        
        self.bot.send_message(self.CHAT_ID, mensagem, parse_mode="Markdown")
        self.sinal_atual_id = None





    def _executar_stop_loss(self):
        """Executa o stop loss quando limite √© atingido"""
        self.bot_ativo = False
        self.nivel_martingale_atual = 0
        self.sinal_atual_id = None
        
        mensagem = (
            "üõë **STOP LOSS ATIVADO** üõë\n\n"
            "‚ö†Ô∏è **Limite de perdas consecutivas atingido**\n\n"
            f"‚è∞ **Pausa de {self.config.pausa_stop_loss_horas}h para prote√ß√£o da banca**\n\n"
            "üß† **A disciplina salvou sua banca!**\n"
            "üìä **Analisando novos padr√µes...**\n"
            "üîÑ **Voltaremos mais fortes!**\n\n"
            "üí° **Aproveite para garantir seu b√¥nus de cadastro!**"
        )
        
        self.bot.send_message(self.CHAT_ID, mensagem, parse_mode="Markdown")
        logger.warning("Stop loss ativado - Bot pausado")
        
        # Agenda reativa√ß√£o
        threading.Timer(
            self.config.pausa_stop_loss_horas * 3600,
            self._reativar_apos_stop_loss
        ).start()
    
    def _reativar_apos_stop_loss(self):
        """Reativa o bot ap√≥s o per√≠odo de stop loss"""
        self.bot_ativo = True
        
        mensagem = (
            "üîÑ **BOT REATIVADO** üîÑ\n\n"
            "‚úÖ **Per√≠odo de pausa finalizado**\n"
            "üéØ **Novos sinais em breve...**\n"
            "üìä **Padr√µes atualizados e analisados**\n\n"
            "üöÄ **Vamos retomar os lucros!**"
        )
        
        self.bot.send_message(self.CHAT_ID, mensagem, parse_mode="Markdown")
        logger.info("Bot reativado ap√≥s stop loss")
    
    def _enviar_menu_configuracao(self, chat_id):
        """Envia menu de configura√ß√£o"""
        mensagem = (
            "‚öôÔ∏è **CONFIGURA√á√ïES DO BOT** ‚öôÔ∏è\n\n"
            f"üí∞ **Banca M√≠nima:** R$ {self.config.banca_minima:.2f}\n"
            f"üé≤ **N√≠veis Martingale:** {len(self.config.martingale_niveis)} n√≠veis\n"
            f"‚è∞ **Intervalo Sinais:** {self.config.intervalo_sinais_minutos} min\n"
            f"üéØ **Taxa Simulada:** {self.config.taxa_vitoria_simulada:.1%}\n"
            f"üõë **Stop Loss:** {self.config.stop_loss_niveis} n√≠veis\n"
            f"‚è∏Ô∏è **Pausa Stop Loss:** {self.config.pausa_stop_loss_horas}h\n\n"
            "Para alterar configura√ß√µes, edite o arquivo config.json"
        )
        
        self.bot.send_message(chat_id, mensagem, parse_mode="Markdown")
    
    def _iniciar_bot_automatico(self):
        """Inicia o modo autom√°tico do bot"""
        self.bot_ativo = True
        self.modo_automatico = True
        
        mensagem = (
            "üöÄ **BOT ELITE ATIVADO** üöÄ\n\n"
            "‚úÖ **Modo autom√°tico iniciado**\n"
            "üéØ **Sinais inteligentes ativados**\n"
            "üìä **An√°lise de padr√µes em tempo real**\n\n"
            f"‚è∞ **Intervalo:** {self.config.intervalo_sinais_minutos} minutos\n"
            f"üí∞ **Banca inicial:** R$ {self.banca_atual:.2f}\n\n"
            "üî• **Prepare-se para os lucros!**"
        )
        
        self.bot.send_message(self.CHAT_ID, mensagem, parse_mode="Markdown")
        logger.info("Bot autom√°tico iniciado")
    
    def _parar_bot_automatico(self):
        """Para o modo autom√°tico do bot"""
        self.bot_ativo = False
        
        mensagem = (
            "‚èπÔ∏è **BOT PAUSADO** ‚èπÔ∏è\n\n"
            "‚úÖ **Modo autom√°tico desativado**\n"
            "üìä **Sinais manuais ainda dispon√≠veis**\n\n"
            "Use /sinal para enviar sinais manualmente"
        )
        
        self.bot.send_message(self.CHAT_ID, mensagem, parse_mode="Markdown")
        logger.info("Bot autom√°tico pausado")
    
    def _enviar_sinal_manual(self):
        """Envia um sinal manual"""
        if self.sinal_atual_id:
            self.bot.send_message(
                self.ADMIN_ID,
                "‚ö†Ô∏è H√° um sinal pendente. Finalize-o primeiro com /green ou /red"
            )
            return
        
        self.enviar_sinal()
        self.bot.send_message(self.ADMIN_ID, "‚úÖ Sinal manual enviado!")
    
    def executar_loop_principal(self):
        """Loop principal do bot autom√°tico"""
        logger.info("üöÄ Bot Elite iniciado!")
        
        # Mensagem inicial
        mensagem_inicial = (
            "ü§ñ **BAC BO ELITE BOT INICIADO** ü§ñ\n\n"
            "üî• **Sistema de sinais premium ativo**\n"
            "üìä **An√°lise inteligente de padr√µes**\n"
            "üí∞ **Gest√£o profissional de banca**\n\n"
            "‚ö° **Aguardando configura√ß√£o...**\n\n"
            "üë®‚Äçüíº **Admins:** Use /start para acessar o painel"
        )
        
        self.bot.send_message(self.CHAT_ID, mensagem_inicial, parse_mode="Markdown")
        
        # Thread para polling do Telegram
        def polling_thread():
            self.bot.polling(none_stop=True, interval=1)
        
        threading.Thread(target=polling_thread, daemon=True).start()
        
        # Loop principal de sinais
        while True:
            try:
                if self.bot_ativo and not self.sinal_atual_id:
                    # Envia novo sinal
                    self.enviar_sinal()
                    
                    # Aguarda resultado (simulado)
                    time.sleep(60)  # 1 minuto para simular tempo de jogo
                    
                    # Simula resultado baseado na taxa configurada
                    vitoria = random.random() < self.config.taxa_vitoria_simulada
                    self._processar_resultado(vitoria)
                    
                    # Aguarda intervalo para pr√≥ximo sinal
                    if self.bot_ativo:
                        logger.info(f"Aguardando {self.config.intervalo_sinais_minutos} minutos...")
                        time.sleep(self.config.intervalo_sinais_minutos * 60)
                
                else:
                    # Bot inativo ou sinal pendente
                    time.sleep(30)
                    
            except Exception as e:
                logger.error(f"Erro no loop principal: {e}")
                time.sleep(60)

def main():
    """Fun√ß√£o principal"""
    try:
        bot = BacBoEliteBot()
        bot.executar_loop_principal()
    except KeyboardInterrupt:
        logger.info("Bot finalizado pelo usu√°rio")
    except Exception as e:
        logger.error(f"Erro fatal: {e}")

if __name__ == "__main__":
    main()


